def year = 2015 // def keyword

def today = new Date() // implicit import java.util.*
def yesterday = today - 1 // overloaded methods previous(), next(), plus(), getAt() ... 

// no primitives, everything is the object
assert 1.plus(2) == 1 + 2
  
assert 42 / 100 == 0.42 // 0 in Java 

String s = 'java.lang.String' // java String in single quotes

// multiline strings - no double quotes escaping, no concatenation
s = '''{
	"year" : 2015,
	"eventName" : "ITSUBBOTNIK"
	"topics": [ 
		"java", 
		"groovy"
	]
}'''

// new string type groovy.lang.GString with placeholders	
def event = "EPAM ITSUBBOTNIK ${year}"; assert event == 'EPAM ITSUBBOTNIK 2015'
 
assert event ==~ /\w+\s\w+\s\d{4}/ // regexp syntax


// groovy.lang.Range

def range = (0..50);	assert 42 in range && range[43] == 43 && range[-1] == 50 

range += (51..100);		assert range[-1] == 100 && range[-1..-3] == [100, 99, 98]  

assert 'b' in ('a'..'c')

// java.util.List

def list = []; 			assert list.class.name == java.util.ArrayList.name

list = [42, today]; list << 'string' // leftShift operator == add()

assert list[0] == 42 && list[-1] == 'string' // negative index - from the end

assert list[0, 2] * 2 == [42, 'string', 42, 'string']

// java.util.Map

def map = [:];	assert map.getClass().name == java.util.LinkedHashMap.name // not map.class.name!

map = ['one': 1, date: today]; map.pi = Math.PI; assert map.size() == 3 && map.pi == Math.PI

assert map.keySet() == ['one', 'date', 'pi'] as Set && map.values() as List == [1, today, Math.PI]


def closure = { /* closure args */ -> /* closure body, implicit return */ }

def outerVariable = 20

closure = { arg0, arg1 ->
	println "Arguments ${ [arg0, arg1] }" // Arguments [1, string]
	outerVariable += arg0 // read-write access to the outer context
}

closure(1, 'string') // call closure

assert outerVariable == 21

// pass closure as an argument to a function
def myFunction(arg1, Closure cl){ cl.call(arg1) }

// special syntax to invoke method with closure as the last param - closure definition out of braces 
assert myFunction ( 'epam',    { it.toUpperCase()  } ) == 'EPAM' 
assert myFunction ( 'ITSUBBOTNIK' ) { it.toLowerCase() }   == 'itsubbotnik' 

// GDK methods: each{}, eachWithIndex{}, collect{}, find{}, findAll{}, eachLine{}, eachRow{}, ...
'epam itsubbotnik 2015'.split(/\s/).collect{ it.toUpperCase() }.eachWithIndex { String w, idx -> 
	println "№ ${idx+1} ${ w.center(outerVariable, '.') }"
}
//№ 1 ........EPAM.........
//№ 2 .....ITSUBBOTNIK.....
//№ 3 ........2015.........

@groovy.transform.Canonical // == @EqualsAndHashCode + @ToString + @TupleConstructor
class Employee { // public by default
	
	def name, salary // implicit getters/setters
	
	def increaseSalary(amount){ 
		salary += amount 
	} 	
}
// many AST transformations: @TypeChecked, @CompileStatic, @Immutable, @Singleton, ...

def emp = new Employee()
emp.name = 'Chuck' // = emp.setName("Chuck")
emp.salary = 1000.0

println emp 		// calls autogenerated toString() method: Employee(Chuck, 1000.0)
println emp.dump()	// GDK method, <Employee@784b85b8 name=Chuck salary=1000.0>

emp = new Employee(name: 'Bruce', salary: 2000.0) // implicit map constructor

// floating point calculation
10000.times { 
	emp.increaseSalary(0.01) 
}

assert emp.salary == 2100 // Groovy floating point numbers are java.math.BigDecimal()

// ----------- Groovy truth
// Strings:
def s1 = ''
def s2 = 'abc'
assert !s1
assert  s2

// Numbers:
def n1 = 0
def n2 = -42
assert !n1
assert  n2

// Lists, maps:
def l1 = [], 		m1 = [:]
def l2 = [1, 3, 6], m2 = ['key': 'value']
assert !l1 && !m1
assert  l2 &&  m2

// Objects:
def o1
def o2 = new Date()
assert !o1
assert  o2

// --- null safety

class A { B b }
class B { C c }
class C { D d }
class D { def value }

def d = new D(value: 'value')
def c = new C(d: d)
def b = new B(c: c)
def a = new A(b: b)

assert a.b.c.d.value == 'value'

b.c = null
assert a.b.c?.d?.value == null // not a.b.c?.d.value


